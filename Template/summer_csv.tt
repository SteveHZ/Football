use Template;
my $tt = Template->new;

$tt->process('my_template', \%data)
   || die $tt->error;

my @teams = ({ name   => 'Man Utd',
              played => 16,
              won    => 12,
              drawn  => 3,
              lost   => 1 },
            { name   => 'Bradford',
              played => 16,
              won    => 2,
              drawn  => 5,
              lost   => 9 });

my %data = ( name   => 'English Premier League',
            season => '2000/01',
            teams  => \@teams );

League Standings

League Name: [% name %]
Season     : [% season %]

Teams:
[% FOREACH team = teams -%]
[% team.name %] [% team.played -%]
[% team.won %] [% team.drawn %] [% team.lost %]
[% END %]



    Template processing directives are surrounded by [% and %] sequences.

    If these tags are replaced with [%- -%] then the preceding or following linefeed is suppressed.

    In the FOREACH loop, each element of the teams list was assigned, in turn, to the temporary variable team.

    Each item assigned to the team variable is a Perl hash. Individual values within the hash are accessed using a dot notation.

It's probably the first and last of these points which are the most important. The first point emphasises the separation of the data acquisition logic from the presentation logic. The person creating the presentation template doesn't need to know Perl, they only need to know the data items which will be passed into the template.

The last point demonstrates the way that TT2 protects the template designer from the implementation of the data structures. The data objects passed to the template processor can be scalars, arrays, hashes, objects or even subroutines. The template processor will just interpret your data correctly and Do The Right Thing to return the correct value to you. In this example each team was a hash, but in a larger system each team might be an object, in which case name, played, etc. would be accessor methods to the underlying object attributes. No changes would be required to the template as the template processor would realise that it needed to call methods rather than access hash values.
A more complex example
Top

Stats about the English Football League are usually presented in a slightly more complex format than the one we used above. A full set of stats will show the number of games that a team has won, lost or drawn, the number of goals scored for and against the team and the number of points that the team therefore has. Teams gain three points for a win and one point for a draw. When teams have the same number of points they are separated by the goal difference, that is the number of goals the team has scored minus the number of team scored against them. To complicate things even further, the games won, drawn and lost and the goals for and against are often split between home and away games.

Therefore if you have a data source which lists the team name together with the games won, drawn and lost and the goals for and against split into home and away (a total of eleven data items) you can calculate all of the other items (goal difference, points awarded and even position in the league). Let's take such a file, but we'll only look at the top three teams. It will look something like this:

Man Utd,7,1,0,26,4,5,2,1,15,6
Arsenal,7,1,0,17,4,2,3,3,7,9
Leicester,4,3,1,10,8,4,2,2,7,4

A simple script to read this data into an array of hashes will look something like this (I've simplified the names of the data columns - w, d, and l are games won, drawn and lost and f and a are goals scored for and against; h and a at the front of a data item name indicates whether it's a home or away statistic):

my @cols = qw(name hw hd hl hf ha aw ad al af aa);

my @teams;
while (<>) {
    chomp;

    my %team;

    @team{@cols} = split /,/;

    push @teams, \%team;
}

We can then go thru the teams again and calculate all of the derived data items:

foreach (@teams) {
    $_->{w} = $_->{hw} + $_->{aw};
    $_->{d} = $_->{hd} + $_->{ad};
    $_->{l} = $_->{hl} + $_->{al};

    $_->{pl} = $_->{w} + $_->{d} + $_->{l};

    $_->{f} = $_->{hf} + $_->{af};
    $_->{a} = $_->{ha} + $_->{aa};

    $_->{gd} = $_->{f} - $_->{a};
    $_->{pt} = (3 * $_->{w}) + $_->{d};
}

And then produce a list sorted in descending order:

@teams = sort {
$b->{pt} <=> $b->{pt} || $b->{gd} <=> $a->{gd}
} @teams;

And finally add the league position data item:

$teams[$_]->{pos} = $_ + 1
    foreach 0 .. $#teams;

Having pulled all of our data into an internal data structure we can start to produce output using out templates. A template to create a CSV file containing the data split between home and away stats would look like this:

[% FOREACH team = teams -%]
[% team.pos %],[% team.name %],[% team.pl %],[% team.hw %],
[%- team.hd %],[% team.hl %],[% team.hf %],[% team.ha %],
[%- team.aw %],[% team.ad %],[% team.al %],[% team.af %],
[%- team.aa %],[% team.gd %],[% team.pt %]
[%- END %]

And processing it like this:

$tt->process('split.tt', { teams => \@teams }, 'split.csv')
  || die $tt->error;

produces the following output:

1,Man Utd,16,7,1,0,26,4,5,2,1,15,6,31,39
2,Arsenal,16,7,1,0,17,4,2,3,3,7,9,11,31
3,Leicester,16,4,3,1,10,8,4,2,2,7,4,5,29

Notice that we've introduced the third parameter to process. If this parameter is missing then the TT2 sends its output to STDOUT. If this parameter is a scalar then it is taken as the name of a file to write the output to. This parameter can also be (amongst other things) a filehandle or a reference to an object which is assumed to implement a print method.

If we weren't interested in the split between home and away games, then we could use a simpler template like this:

[% FOREACH team = teams -%]
[% team.pos %],[% team.name %],[% team.pl %],[% team.w %],
[%- team.d %],[% team.l %],[% team.f %],[% team.a %],
[%- team.aa %],[% team.gd %],[% team.pt %]
[% END -%]

Which would produce output like this:

1,Man Utd,16,12,3,1,41,10,6,31,39
2,Arsenal,16,9,4,3,24,13,9,11,31
3,Leicester,16,8,5,3,17,12,4,5,29

Producing XML
Top

This is starting to show some of the power and flexibility of TT2, but you may be thinking that you could just as easily produce this outp
